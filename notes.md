## 02 - React Native Basics [COURSE GOALS APP]

### 002 Exploring Core Components & Component Styling

React Native компилирует компоненты в соответствующие нативные элементы. Например:
`<View> = <div> = android.View = UIView`
В нём нельзя использовать DOM-элементы.
Соответственно, когда мы создаём свои компоненты - мы просто создаём комбинации Основных компонентов React Native и других встроенных компонентов.
CSS не существует в React Native. Можно использовать:

- inline styles
- StyleSheet Objects
  Это всё пишется на JS. И хотя эти стили основаны на CSS, они включают в себя лишь часть существующих свойств и параметров.

### 003 Working With Core Components

Текст нельзя напрямую помещать в `<View></View>`.
`<View>` используется для того, чтобы вмещать в себя другие компоненты и размещать их каким-то образом.
`<Text>` используется для того, чтобы выводить текст.
Одна из особенностей React Native - это то, что что все основные компоненты нужно импортировать из `"react-native"`
`<Button title="smth"/>` кнопка - это самозакрывающийся тэг. Текст внутри неё прописывается в атрибуте `title`.

### 004 Styling React Native Apps

В целом, стили можно прописывать не только в `const styles = StyleSheet.create({})`, но и в обычном объекте. Но StyleSheet выдаёт нам подсказки, автозаполнение, и выводит ошибки и предупреждения.

### 008 Using Flexbox To Create Layouts

Flexbox по умолчанию применяется ко всем `<View>`, и они по умолчанию `flexDirection: "column",`

### 010 Improving The Layout

У компонента <Button/> нет пропа `style`, так что мы не можем его стилизовать. Но можно создать свою собственную кнопку.

### 011 Handling Events

Для обработки событий в React Native используются свои обработчики. Например, для `TextInput` используется `onChangeText`. Этот обработчик передаст введённое значение в предоставленную ему функцию автоматически.
`console.log()` Выведет значение в консоль, где запущен процесс `npm run start`
Для `Button` используется обработчик событий `onPress`

### 013 iOS & Android Styling Differences

Иногда одни и те же стили выглядят по-разному на разных платформах, потому что они конвертируются в разные нативные элементы. Например, на Андроиде `<Text>` может иметь скруглённые углы, а на iOS - нет. Поэтому там, где эти углы нам всё же необходимы, нужно использовать `<View>`. Другие стили также могут отличаться. это нужно перепроверять и уточнять в документации.

В отличие от обычного CSS, в React Native стилях стили не имеют каскадности и не наследуются дочерними элементами.

### 015 Optimizing Lists with FlatList

`<ScrollView>` всегда рендерит всё, что в нём есть и не очень подходит для списков, т.к. это может тормозить приложение, если дочерних элементов слишком много. Его можно использовать для чего-то вроде длинной статьи.
Для списков же лучше использовать `<FlatList>`, который будет рендерить только элементы в поле видимости и будет подгружать элементы вне экрана используя lazy-loading.
Но если в `<ScrollView>` мы просто помещаем контент ммежду открывающим и закрывающим тэгами (и используем `list.map((el) => <View>smth...</View>)`), то `<FlatList>` должен получить два пропа:

```
  <FlatList
    data={<массив данных>}
    renderItem={(itemData) => {
      return (
        <View style={styles.goalItem}>
          <Text style={styles.goalText}>{itemData.item.text}</Text> // сами данные лежат в .item
        </View>
      );
    }}
  />
```

И хотя мы открыто не прописываем проп `key`, всё-таки он нужен `FlatList`-у. Поэтому лучше всего передавать в него не просто массив данных, а массив объектов вида

```
  {
    key= 12345,
    text: 'smth'
  }

```

, откуда FlatList самостоятельно возьмёт `key`. И, соответственно, нужно брать не просто `item`, а `item.text`.

Но если по какой-то причине нам так делать неудобно, можно просто добавить к `FlatList` ещё один проп, который извлечёт `key` таким образом, которым мы ему укажем:

```
  keyExtractor={(item, index) => {
    return item.id;
  }}
```

### 019 Handling Taps with the Pressable Component

Для компонентов, на которые пользователь будет нажимать, нужно использовать компонент `Pressable`. Есть старые компоненты `Touchable`, но они уже устаревают и лучше их не использовать.

### 021 Adding an Android Ripple Effect & an iOS Alternative

На Андроиде можно добавить специальный эффект при нажатии на `Pressable`, используя проп `android_ripple`. В нём можно прописать цвет, который наложится на элемент при нажатии.
На iOS такого нет. Зато вместо этого можно использовать особые стили по условию:

```
  <Pressable
    android_ripple={{ color: "#000000" }}
    onPress={onDeleteItem}
    style={({ pressed }) => pressed && styles.pressedItem} // стиль pressedItem применится только в тот момент, когда элемент будет нажат.
  >
  </Pressable>
```

### 022 Adding a Modal Screen

Хотя добавить стили элементу `<Button/>` мы и не можем, но можно установить ей проп `color`.

### 023 Styling the Modal Overlay

Ещё стиль кнопок можно немного поменять, если обернуть их во `View` и стилизовать его. Так, например, можно повлиять на размер кнопок и внешние отступы.

### 025 Working with Images & Changing Colors

Чтобы вставлять изображения, нужно использовать компонент `<Image />`. Но путь до картинки нужно указывать не напрямую, а через испорт при помощи `require`:

```
<Image source={require("../assets/images/goal.png")} />
```

### 026 App Finishing Touches

Если нам ужно установить один и тот же фон для всего приложения, его нужно прописать в `app.json` вот так:

```
"backgroundColor": "#1e085a",
```

и тогда его не придётся прописывать для каждого экрана (но для модалок, тем не менее, указывать фон нужно).

Чтобы поменять цвет статус-бара, нужно использовать специальный компонент и указать в нём строкой нужный стиль:

```
<StatusBar style="light" /> // light / dark / inverted / auto
```
